// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Printf = require("bs-platform/lib/js/printf.js");
var $$String = require("bs-platform/lib/js/string.js");
var ReasonReact = require("reason-react/src/ReasonReact.js");

function filteri(f, lst) {
  return List.fold_left((function (param, v) {
                  var l = param[1];
                  var i = param[0];
                  if (Curry._2(f, i, v)) {
                    return /* tuple */[
                            i + 1 | 0,
                            /* :: */[
                              v,
                              l
                            ]
                          ];
                  } else {
                    return /* tuple */[
                            i + 1 | 0,
                            l
                          ];
                  }
                }), /* tuple */[
                0,
                /* [] */0
              ], lst)[1];
}

var component = ReasonReact.reducerComponent("Page");

function handleText(codeNum, $$event, self) {
  var target = $$event.target;
  var content = target.value;
  if (content === "") {
    return Curry._1(self[/* send */4], /* DeleteTextBox */Block.__(1, [codeNum]));
  } else {
    return Curry._1(self[/* send */4], /* UpdateAndCompile */Block.__(0, [
                  codeNum,
                  content
                ]));
  }
}

var preamble = "\ntype rowT = {width: int, height: int, color: string};\ntype svgRectT = {x: int, y: int, w: int, h: int, c: string};\nlet processRow = (row: rowT) : svgRectT => { row\n";

function processRow() {
  return 4;
}

function wrapFunction(body) {
  return Curry._1(Printf.sprintf(/* Format */[
                  /* String_literal */Block.__(11, [
                      "|> ((x) => {",
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* String_literal */Block.__(11, [
                              "})",
                              /* End_of_format */0
                            ])
                        ])
                    ]),
                  "|> ((x) => {%s})"
                ]), body);
}

function doCompile(state) {
  console.log("Compiling...");
  var reason_code = $$String.concat("\n", List.map(wrapFunction, state[/* textList */0]));
  var wrapped_code = preamble + (reason_code + "}");
  var maybeRE;
  try {
    maybeRE = /* Ok */Block.__(0, [parseRE(wrapped_code)]);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Js_exn.$$Error) {
      var match = exn[1].message;
      maybeRE = match !== undefined ? /* Error */Block.__(1, [match]) : /* Error */Block.__(1, ["Unknown reason parsing error"]);
    } else {
      throw exn;
    }
  }
  if (maybeRE.tag) {
    return /* record */[
            /* textList */state[/* textList */0],
            /* error : Some */[maybeRE[0]],
            /* output */state[/* output */2],
            /* data */state[/* data */3]
          ];
  } else {
    var ocaml$1 = printML(maybeRE[0]);
    var js = ocaml.compile(ocaml$1);
    var match$1 = js.js_error_msg;
    if (match$1 == null) {
      var match$2 = eval(js.js_code);
      if (match$2 == null) {
        return /* record */[
                /* textList */state[/* textList */0],
                /* error : Some */["Error when evaling code"],
                /* output */state[/* output */2],
                /* data */state[/* data */3]
              ];
      } else {
        console.log(match$2);
        return /* record */[
                /* textList */state[/* textList */0],
                /* error : None */0,
                /* output : Some */[$$Array.map(match$2, state[/* data */3])],
                /* data */state[/* data */3]
              ];
      }
    } else {
      var re = new RegExp("This expression has type [a-zA-Z]+ but an expression was expected of type\\s+svgRectT");
      if (re.test(match$1)) {
        return /* record */[
                /* textList */List.rev(/* :: */[
                      "",
                      List.rev(state[/* textList */0])
                    ]),
                /* error : None */0,
                /* output */state[/* output */2],
                /* data */state[/* data */3]
              ];
      } else {
        return /* record */[
                /* textList */state[/* textList */0],
                /* error : Some */[match$1],
                /* output */state[/* output */2],
                /* data */state[/* data */3]
              ];
      }
    }
  }
}

function createRow(id, row) {
  return React.createElement("tr", {
              key: String(id)
            }, React.createElement("td", {
                  style: {
                    border: "1px solid black"
                  }
                }, String(row[/* width */0])), React.createElement("td", {
                  style: {
                    border: "1px solid black"
                  }
                }, String(row[/* height */1])), React.createElement("td", {
                  style: {
                    border: "1px solid black"
                  }
                }, row[/* color */2]));
}

function make() {
  var newrecord = component.slice();
  newrecord[/* render */9] = (function (self) {
      var match = self[/* state */2][/* error */1];
      var match$1 = self[/* state */2][/* output */2];
      return React.createElement("div", undefined, React.createElement("table", {
                      style: {
                        border: "1px solid black"
                      }
                    }, React.createElement("thead", undefined, React.createElement("tr", undefined, React.createElement("th", undefined, "width"), React.createElement("th", undefined, "height"), React.createElement("th", undefined, "color"))), React.createElement("tbody", undefined, $$Array.mapi(createRow, self[/* state */2][/* data */3]))), React.createElement("br", undefined), React.createElement("br", undefined), $$Array.mapi((function (i, text) {
                        return React.createElement("div", {
                                    key: String(i)
                                  }, "(x) => {", React.createElement("br", undefined), React.createElement("textarea", {
                                        style: {
                                          height: "100px",
                                          marginTop: "5px",
                                          marginLeft: "30px",
                                          width: "300px"
                                        },
                                        name: "textarea",
                                        value: text,
                                        onChange: (function ($$event) {
                                            return handleText(i, $$event, self);
                                          })
                                      }), React.createElement("br", undefined), "}", React.createElement("br", undefined));
                      }), $$Array.of_list(self[/* state */2][/* textList */0])), React.createElement("br", undefined), match ? React.createElement("div", undefined, React.createElement("br", undefined), match[0]) : null, React.createElement("svg", {
                      height: "100",
                      width: "100"
                    }, match$1 ? $$Array.mapi((function (i, svgRect) {
                              return React.createElement("rect", {
                                          key: String(i),
                                          style: {
                                            fill: svgRect[/* c */4]
                                          },
                                          height: String(svgRect[/* h */3]),
                                          width: String(svgRect[/* w */2])
                                        });
                            }), match$1[0]) : null));
    });
  newrecord[/* initialState */10] = (function () {
      return /* record */[
              /* textList : :: */[
                "{x: 1, y: 1, w: row.width, h: row.height, c: row.color}",
                /* [] */0
              ],
              /* error : None */0,
              /* output : None */0,
              /* data : array */[
                /* record */[
                  /* width */20,
                  /* height */40,
                  /* color */"blue"
                ],
                /* record */[
                  /* width */40,
                  /* height */30,
                  /* color */"red"
                ]
              ]
            ];
    });
  newrecord[/* reducer */12] = (function (action, state) {
      if (action.tag) {
        var textNum = action[0];
        if (List.length(state[/* textList */0]) === 1) {
          return /* Update */Block.__(0, [/* record */[
                      /* textList : :: */[
                        "",
                        /* [] */0
                      ],
                      /* error */state[/* error */1],
                      /* output */state[/* output */2],
                      /* data */state[/* data */3]
                    ]]);
        } else {
          var newTextList = filteri((function (i, _) {
                  return +(i !== textNum);
                }), state[/* textList */0]);
          return /* Update */Block.__(0, [/* record */[
                      /* textList */newTextList,
                      /* error */state[/* error */1],
                      /* output */state[/* output */2],
                      /* data */state[/* data */3]
                    ]]);
        }
      } else {
        var text = action[1];
        var textNum$1 = action[0];
        var newTextList$1 = List.mapi((function (i, x) {
                if (i === textNum$1) {
                  return text;
                } else {
                  return x;
                }
              }), state[/* textList */0]);
        return /* Update */Block.__(0, [doCompile(/* record */[
                        /* textList */newTextList$1,
                        /* error */state[/* error */1],
                        /* output */state[/* output */2],
                        /* data */state[/* data */3]
                      ])]);
      }
    });
  return newrecord;
}

exports.filteri = filteri;
exports.component = component;
exports.handleText = handleText;
exports.preamble = preamble;
exports.processRow = processRow;
exports.wrapFunction = wrapFunction;
exports.doCompile = doCompile;
exports.createRow = createRow;
exports.make = make;
/* component Not a pure module */
